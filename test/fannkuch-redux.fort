;; types
Int = /unsigned 32 ;; BAL: make this signed
Perm = /address (/array 12 Int) ;; BAL: make this configurable
Bool = /bool

;; primitives
add: (a, a) -> a
+ = add
equals: (a, a) -> Bool
== = equals
less-than: (a, a) -> Bool
< = less-than
output: a -> ()

subtract: (a, a) -> a
- = subtract

greater-than-or-equals: (a, a) -> Bool
>= = greater-than-or-equals

store: (/address a, a) -> ()
:= = store

load: /address a -> a
;; BAL: support unary operators @ = load

index: (/address (/array sz a), Int) -> /address a
# = index

cast: a -> b

;; code
is-odd: Int -> Bool = cast

num-flips: Perm -> Int = \p => go 0
  /where
    go: Int -> Int = \n => /case load (p # 0) /of
      1 = n
      \i => /do
        reverse-n (i, p)
        output p
        go (n + 1)

;; BAL: try multiply version when benchmarking
checksum: (Int, Int) -> Int = \(csum, n-flips) => /if
  is-odd n-flips = csum - n-flips
  _ = csum + n-flips
  
max: (Int, Int) -> Int = \(x, y) => /if
  x >= y = x
  _ = y

foo: (Int, Int, Perm) -> () = \(m0, csum0, perm) => /do
  /let n = num-flips perm
  /let m = max (m0, n)
  /let csum = checksum(csum0, n)
  output n
  ;; output m
 ;; output csum

reverse-n: (Int, Perm) -> () = \(n, p) => go (0, n - 1)
  /where
    go: (Int, Int) -> () = \(l,r) => /if
      l >= r = ()
      _ = /do
        swap (p # l, p # r)
        go (l + 1, r - 1)

swap: (/address Int, /address Int) -> () = \(p,q) => /do
  /let temp = load p
  p := load q
  q := temp

inc: /address Int -> () = \p => p := (load p + 1)

array: (Int -> a) -> /address (/array sz a)

unsafe-array: /address (/array sz a)

linear: Int -> Int = \i => i + 1 ;; BAL: inline
zeros: Int -> Int = \_ => 0 ;; BAL: inline

;; array-linear: /address (/array sz a) = /do
;; array-zeros: /address (/array sz a)

array-size: /address (/array sz a) -> Int

;; blah: /address (/array sz a) -> () = \arr => go 0
init-linear: Perm -> () = \arr => go 0
  /where
    go: Int -> () = \i => /if
      i < array-size arr = /do ;; BAL: go backwards?  use an input size?
        (arr # i) := (i + 1)
        go (i + 1)
      _ = ()

init-zeros: Perm -> () = \arr => go 0
  /where
    go: Int -> () = \i => /if ;; BAL: go backwards?  use an input size?
      i < array-size arr = /do
        (arr # i) := 0
        go (i + 1)
      _ = ()

permutations: Int -> () = \size => /do
;;  /let perm: Perm = array-linear ;; [ 1 .. ]
  ;; /let c: Perm = array-zeros ;; repeat 0
  /let perm: Perm = unsafe-array
  /let c: Perm = unsafe-array
  init-linear perm
  init-zeros c
  output perm
  go (0, foo(0, 0, perm)) ;; BAL: go backwards?
    /where
      go: (Int, Int) -> () = \(i, mx) => /if
        i < size = /if
          load (c # i) < i = /do
            /if
              is-odd i = swap (perm # load (c # i), perm # i)
              /else = swap (perm # 0, perm # i)
            inc (c # i)
            output perm
            go (0, foo(mx, 0, perm))
          _ = /do
          (c # i) := 0
          go (i + 1, mx)
        _ = ()

