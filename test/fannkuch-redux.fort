;; types
Int = /unsigned 32 ;; BAL: make this signed
SInt = /signed 32
Perm = /address (/array 12 Int) ;; BAL: make this configurable
Bool = /bool

;; primitives
add: (a, a) -> a
+ = add
equals: (a, a) -> Bool
== = equals
greater-than: (a, a) -> Bool
> = greater-than
less-than: (a, a) -> Bool
< = less-than
output: a -> ()

subtract: (a, a) -> a
- = subtract

greater-than-or-equals: (a, a) -> Bool
>= = greater-than-or-equals

store: (/address a, a) -> ()
:= = store

load: /address a -> a
;; BAL: support unary operators @ = load

index: (/address (/array sz a), Int) -> /address a
# = index

cast: a -> b

;; code
is-odd: Int -> Bool = cast

max: (Int, Int) -> Int = \(x, y) => /if
  x >= y = x
  _ = y

;; St = /record
;;   max-flips: Int
;;   checksum: SInt
;;   perm-count: Int

;; BAL: try multiply version when benchmarking
;; calc-checksum: (SInt, Int, Int) -> SInt = \(csum, n-flips, i) => /if
;;   is-odd i = csum - cast n-flips
;;   _ = csum + cast n-flips
  
;; inc: /address Int -> () = \p => p := (load p + 1)
dec: /address Int -> () = \p => p := (load p - 1)

array: (Int -> a) -> /address (/array sz a)

unsafe-array: /address (/array sz a)

;; linear: Int -> Int = \i => i + 1 ;; BAL: inline
;; zeros: Int -> Int = \_ => 0 ;; BAL: inline

;; ;; array-linear: /address (/array sz a) = /do
;; ;; array-zeros: /address (/array sz a)

array-size: /address (/array sz a) -> Int

init-linear: Perm -> () = \arr => go 0
  /where
    go: Int -> () = \i => /if
      i < array-size arr = /do ;; BAL: go backwards?  use an input size?
        (arr # i) := i
        go (i + 1)
      _ = ()

init-copy: (Perm, Perm) -> () = \(a, b) => go 0
  /where
    go: Int -> () = \i => /if ;; BAL: go backwards?  use an input size?
      i < array-size a = /do
        (a # i) := load (b # i)
        go (i + 1)
      _ = ()

perms: () -> Int = \_ => permutations(2)

permutations: Int -> Int = \n => /do
  /let perm: Perm = unsafe-array
  init-linear perm
  /let count: Perm = unsafe-array
  /let flips: Perm = unsafe-array
  ;; init-zeros count ;; BAL: don't need this
  ;; output perm

  computePerms (n, 0)
    /where
      computePerms: (Int, Int) -> Int = \(r0, idx) => /do
        ;; /let mx = max (mx0, n)
        /let n = num-flips perm
        ;; /let csum = calc-checksum(csum0, n, idx)
        updateCounts r0
        /let r: Int = computeNextPerm 1
        /if
          r < n = computePerms (r, idx + 1)
          _ = r ;; /do
            ;; output mx
            ;; output csum

      updateCounts: Int -> () = \r0 =>
        /if
          r0 > 1 = /do
            /let r: Int = r0 - 1
            (count # r) := r0
            updateCounts r
          _ = ()

      computeNextPerm: Int -> Int = \r => /do
        rotateSubPerm r
        dec (count # r)
        
        /if
          load (count # r) > 0 = r
          _ = computeNextPerm (r + 1)

      rotateSubPerm: Int -> () = \r => /do
        /let perm0 = load (perm # 0)
        rot 0
          /where
            rot: Int -> () = \i =>
              /if
                i < r = /do
                  (perm # i) := load (perm # (i + 1))
                  rot (i + 1)
                _ = (perm # r) := perm0

      num-flips: Perm -> Int = \asdf => /do
        init-copy (flips, perm)
        goX 0
          /where
            goX: Int -> Int = \nX => /case load (flips # 0) /of
              1 = nX
              \iX => /do
                reverse-n (iX)
                ;; output p
                goX (nX + 1)

      reverse-n: (Int) -> () = \(nXX) => goXX (0, nXX - 1)
        /where
          goXX: (Int, Int) -> () = \(lXX, rXX) => /if
            lXX >= rXX = ()
            _ = /do
              swap (flips # lXX, flips # rXX)
              goXX (lXX + 1, rXX - 1)

      swap: (/address Int, /address Int) -> () = \(pXXX, qXXX) => /do
        /let temp = load pXXX
        pXXX := load qXXX
        qXXX := temp


      ;; num-flips: Perm -> Int = \permX => /do
      ;;   /let pX = unsafe-array
      ;;   init-copy (pX, permX)
      ;;   goX 0
      ;;     /where
      ;;       goX: Int -> Int = \nX => /case load (pX # 0) /of
      ;;         1 = nX
      ;;         \iX => /do
      ;;           reverse-n (iX, pX)
      ;;           ;; output p
      ;;           goX (nX + 1)

      ;; reverse-n: (Int, Perm) -> () = \(nXX, pXX) => goXX (0, nXX - 1)
      ;;   /where
      ;;     goXX: (Int, Int) -> () = \(lXX, rXX) => /if
      ;;       lXX >= rXX = ()
      ;;       _ = /do
      ;;         swap (pXX # lXX, pXX # rXX)
      ;;         goXX (lXX + 1, rXX - 1)

;; init-zeros: Perm -> () = \arr => go 0
;;   /where
;;     go: Int -> () = \i => /if ;; BAL: go backwards?  use an input size?
;;       i < array-size arr = /do
;;         (arr # i) := 0
;;         go (i + 1)
;;       _ = ()

;; fannkuch: (Int, SInt, Int, Perm) -> St = \(m0, csum0, i, Perm) => /do
;;   /let n = num-flips perm
;;   /let m = max (m0, n)
;;   /let csum = calc-checksum(csum0, n, i)
;;   output n
;;   output i
;;   output csum
;;   { ;; BAL: fix parser
;;     ; max-flips = m
;;     ; checksum = csum
;;     ; perm-count = i + 1
;;     }
