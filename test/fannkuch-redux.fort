;; types
Int = /unsigned 32
Perm = /address (/array 12 Int) ;; BAL: make this configurable
Bool = /bool

;; primitives
add: (a, a) -> a
+ = add
equals: (a, a) -> Bool
== = equals
less-than: (a, a) -> Bool
< = less-than
output: a -> ()

subtract: (a, a) -> a
- = subtract

greater-than-or-equals: (a, a) -> Bool
>= = greater-than-or-equals

store: (/address a, a) -> ()
:= = store

load: /address a -> a
;; BAL: support unary operators @ = load

index: (/address (/array sz a), Int) -> /address a
# = index

cast: a -> b

;; code
is-odd: Int -> Bool = cast

fannkuch: Perm -> Int = \p => go 0
  /where
    go: Int -> Int = \num-flips => /case load (p # 0) /of
      1 = num-flips
      \i => /do
        reverse-n (i, p)
        go (num-flips + 1)

;; BAL: try multiply version when benchmarking
checksum: (Int, Int) -> Int = \(csum, n-flips) => /if
  is-odd n-flips = csum - n-flips
  _ = csum + n-flips
  
reverse-n: (Int, Perm) -> () = \(n,p) => go (0, n - 1)
  /where
    go: (Int, Int) -> () = \(l,r) => /if
      l >= r = ()
      _ = /do
        swap (p # l, p # r)
        go (l + 1, r - 1)

swap: (/address Int, /address Int) -> () = \(p,q) => /do
  /let temp = load p
  p := load q
  q := temp

inc: /address Int -> () = \p => p := (load p + 1)

;; array: (Int -> a) -> /address (/array sz a)

linear: Int -> Int = \i => i + 1 ;; BAL: inline
zeros: Int -> Int = \_ => 0 ;; BAL: inline

;; permutations: Int -> () = \size => /do
;;   /let perm: Perm = array linear ;; [ 1 .. ]
;;   /let c: Perm = array zeros ;; repeat 0
;;   output perm
  ;; go 0 ;; BAL: go backwards?
  ;;   /where
  ;;     go: Int -> () = \i => /if
  ;;       i < size = /if
  ;;         load (c # i) < i = /do
  ;;           /if
  ;;             is-odd i = swap (perm # load (c # i), perm # i)
  ;;             /else = swap (perm # 0, perm # i)
  ;;           output perm
  ;;           inc (c # i)
  ;;           go 0
  ;;         _ = /do
  ;;         (c # i) := 0
  ;;         go (i + 1)
  ;;       _ = ()
