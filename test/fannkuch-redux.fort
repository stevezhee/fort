;; types
Int = /unsigned 32 ;; BAL: make this signed
SInt = /signed 32
Perm = /address (/array 12 Int) ;; BAL: make this configurable
Bool = /bool

;; primitives
add: (a, a) -> a
+ = add
equals: (a, a) -> Bool
== = equals
greater-than: (a, a) -> Bool
> = greater-than
less-than: (a, a) -> Bool
< = less-than
output: a -> ()

subtract: (a, a) -> a
- = subtract

greater-than-or-equals: (a, a) -> Bool
>= = greater-than-or-equals

store: (/address a, a) -> ()
:= = store

load: /address a -> a
;; BAL: support unary operators @ = load

index: (/address (/array sz a), Int) -> /address a
# = index

cast: a -> b

;; code
is-odd: Int -> Bool = cast

max: (Int, Int) -> Int = \(x, y) => /if
  x >= y = x
  _ = y

;; St = /record
;;   max-flips: Int
;;   checksum: SInt
;;   perm-count: Int

;; BAL: try multiply version when benchmarking
calc-checksum: (SInt, Int, Int) -> SInt = \(csum, n-flips, i) => /if
  is-odd i = csum - cast n-flips
  _ = csum + cast n-flips
  
;; inc: /address Int -> () = \p => p := (load p + 1)
dec: /address Int -> () = \p => p := (load p - 1)

;; array: (Int -> a) -> /address (/array sz a)

unsafe-array: /address (/array sz a)

;; linear: Int -> Int = \i => i + 1 ;; BAL: inline
;; zeros: Int -> Int = \_ => 0 ;; BAL: inline

;; array-linear: /address (/array sz a) = /do
;; array-zeros: /address (/array sz a)

array-size: /address (/array sz a) -> Int

init-linear: Perm -> () = \arr => go 0
  /where
    go: Int -> () = \i => /if
      i < array-size arr = /do ;; BAL: go backwards?  use an input size?
        (arr # i) := i
        go (i + 1)
      _ = ()

init-copy: (Perm, Perm) -> () = \(a, b) => go 0
  /where
    go: Int -> () = \i => /if ;; BAL: go backwards?  use an input size?
      i < array-size a = /do
        (a # i) := load (b # i)
        go (i + 1)
      _ = ()

;; perms: () -> Int = \_ => permutations(2)

permutations: Int -> Int = \n => /do
  /let perm: Perm = unsafe-array
  /let count: Perm = unsafe-array
  init-linear perm

  computePerms (n, 0, 0, 0)
    /where
      computePerms: (Int, Int, Int, SInt) -> Int = \(r0, idx, mx0, csum0) => /do
        /let n = num-flips perm
        /let mx = max (mx0, n)
        /let csum = calc-checksum(csum0, n, idx)
        updateCounts r0
        /let r: Int = computeNextPerm 1
        /if
          r < n = computePerms (r, idx + 1, mx, csum)
          _ = r

      updateCounts: Int -> () = \r0 =>
        /if
          r0 > 1 = /do
            /let r: Int = r0 - 1
            (count # r) := r0
            updateCounts r
          _ = ()

      computeNextPerm: Int -> Int = \r => /do
        rotateSubPerm r
        dec (count # r)
        
        /if
          load (count # r) > 0 = r
          _ = computeNextPerm (r + 1)

      rotateSubPerm: Int -> () = \r => /do
        /let perm0 = load (perm # 0)
        rot 0
          /where
            rot: Int -> () = \i =>
              /if
                i < r = /do
                  (perm # i) := load (perm # (i + 1))
                  rot (i + 1)
                _ = (perm # r) := perm0

num-flips: Perm -> Int = \perm => /do
  /let arr: Perm = unsafe-array
  init-copy (arr, perm)
  go 0
    /where
      go: Int -> Int = \n => /case load (arr # 0) /of
        1 = n
        \i => /do
          reverse-n (i, arr)
          ;; output p
          go (n + 1)

reverse-n: (Int, Perm) -> () = \(n, arr) => go (0, n - 1)
  /where
    go: (Int, Int) -> () = \(l, r) => /if
      l >= r = ()
      _ = /do
        swap (arr # l, arr # r)
        go (l + 1, r - 1)

swap: (/address Int, /address Int) -> () = \(p, q) => /do
  /let temp = load p
  p := load q
  q := temp


;; init-zeros: Perm -> () = \arr => go 0
;;   /where
;;     go: Int -> () = \i => /if ;; BAL: go backwards?  use an input size?
;;       i < array-size arr = /do
;;         (arr # i) := 0
;;         go (i + 1)
;;       _ = ()

;; fannkuch: (Int, SInt, Int, Perm) -> St = \(m0, csum0, i, Perm) => /do
;;   /let n = num-flips perm
;;   /let m = max (m0, n)
;;   /let csum = calc-checksum(csum0, n, i)
;;   output n
;;   output i
;;   output csum
;;   { ;; BAL: fix parser
;;     ; max-flips = m
;;     ; checksum = csum
;;     ; perm-count = i + 1
;;     }
