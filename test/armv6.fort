;; ┌┬┐┬ ┬┌─┐┌─┐┌─┐
;;  │ └┬┘├─┘├┤ └─┐
;;  ┴  ┴ ┴  └─┘└─┘

UInt32 = /unsigned 32
Pointer = /address (/unsigned 32)
Bit = /unsigned 1

;; ┌─┐┬─┐┬┌┬┐┬┌┬┐┬┬  ┬┌─┐┌─┐
;; ├─┘├┬┘│││││ │ │└┐┌┘├┤ └─┐
;; ┴  ┴└─┴┴ ┴┴ ┴ ┴ └┘ └─┘└─┘

load_volatile: /address a -> a
store_volatile: (/address a, a) -> ()
inttoptr: UInt32 -> Pointer

;; ┌─┐┌─┐┌─┐┬─┐┌─┐┌┬┐┌─┐┬─┐┌─┐
;; │ │├─┘├┤ ├┬┘├─┤ │ │ │├┬┘└─┐
;; └─┘┴  └─┘┴└─┴ ┴ ┴ └─┘┴└─└─┘

+ = add
add: (UInt32, UInt32) -> UInt32

<< = shift_left
shift_left: (UInt32, UInt32) -> UInt32

>> = logical_shift_right
logical_shift_right: (UInt32, UInt32) -> UInt32

& = bitwise_and
bitwise_and: (UInt32, UInt32) -> UInt32

| = bitwise_or
bitwise_or: (UInt32, UInt32) -> UInt32

;; ┌─┐┌─┐┌┐┌┌─┐┌┬┐┌─┐┌┐┌┬┐┌─┐
;; │  │ ││││└─┐ │ ├─┤││││ └─┐
;; └─┘└─┘┘└┘└─┘ ┴ ┴ ┴┘└┘┴ └─┘

periph_base: UInt32 = 1073741824 ;; 0x40000000

cmu_base: UInt32 = periph_base + 209715200 ;; 0xc8000
cmu_gpio: UInt32 = _reg_bit(68, 8) ;; 0x44

wdog_base: UInt32 = periph_base + 142606336 ;; 0x88000
wdog_ctrl: UInt32 = wdog_base

ppbi_base: UInt32 = 3758096384 ;; 0xE0000000U
scs_base: UInt32 = ppbi_base + 57344 ;; 0xE000
sys_tick_base: UInt32 = scs_base + 16 ;; 0x0010

stk_csr_clksource_lsb: UInt32 = 2
stk_csr_clksource: UInt32 = 1 << stk_csr_clksource_lsb
stk_csr_clksource_flipped: UInt32 = 251
stk_csr_clksource_ahb: UInt32 = 1 << stk_csr_clksource_lsb

stk_csr: UInt32 = sys_tick_base
stk_csr_tickint: UInt32 = 1 << 1
stk_csr_enable: UInt32 = 1 << 0

stk_rvr: UInt32 = sys_tick_base + 4 ;; 0x04
stk_rvr_reload: UInt32 = 16777215 ;; 0x00FFFFFF

gpio_base: UInt32 = periph_base + 1536 ;; 0x06000
gpio_pa: UInt32 = gpio_base
gpio_pb: UInt32 = gpio_base + 36
gpio0: UInt32 = 1 << 0
gpio7: UInt32 = 1 << 7

led_green_port: UInt32 = gpio_pa
led_green_pin: UInt32 = gpio0
led_red_port: UInt32 = gpio_pb
led_red_pin: UInt32 = gpio7

;; TODO
;; GPIO_P_MODEL(port)          MMIO32((port) + 0x04)
;; GPIO_P_MODEH(port)          MMIO32((port) + 0x08)
;; GPIO_P_MODE_MODEx_MASK(x)   (0x0F << (((x) & 0x7) * 4))
;; GPIO_P_MODE_MODEx(x, mode)  (((mode) << (((x) & 0x7) * 4)) & GPIO_P_MODE_MODEx_MASK(x))

;; ┌─┐┬ ┬┌┐┌┌─┐┌┬┐┬┌─┐┌┐┌┌─┐
;; ├┤ │ │││││   │ ││ ││││└─┐
;; └  └─┘┘└┘└─┘ ┴ ┴└─┘┘└┘└─┘

get_register: UInt32 -> UInt32 = \a => /do
  /let pointer = inttoptr a
  load_volatile pointer

set_register: (UInt32, UInt32) -> () = \(a,b) => /do
  /let pointer = inttoptr a
  store_volatile (pointer, b)

_reg_bit: (UInt32, UInt32) -> UInt32 = \(base, bit) => /do
  (base << 5) + bit

enable_gpio_clock: Bit -> () = \_ => /do
  /let reg = cmu_base + (cmu_gpio >> 5)
  /let val = 1 << (cmu_gpio & 31)
  set_register (reg, val)

;; TODO
;; void gpio_setup(uint32_t gpio_port, enum gpio_mode mode, uint16_t gpios)
;; {
;;   unsigned i;
;;
;;   uint32_t high = GPIO_P_MODEH(gpio_port);
;;   uint32_t low = GPIO_P_MODEL(gpio_port);
;;
;;   for (i = 0; i < 8; i++) {
;;     if (gpios & (1 << i)) {
;;       low &= ~GPIO_P_MODE_MODEx_MASK(i);
;;       low |= GPIO_P_MODE_MODEx(i, mode);
;;     }
;;
;;     if (gpios & (1 << (i + 8))) {
;;       high &= ~GPIO_P_MODE_MODEx_MASK(i);
;;       high |= GPIO_P_MODE_MODEx(i, mode);
;;     }
;;   }
;;
;;   GPIO_P_MODEL(gpio_port) = low;
;;   GPIO_P_MODEH(gpio_port) = high;
;; }

gpio_set: (UInt32, UInt32) -> () = \(gpio_port, gpios) => /do
  set_register (gpio_port + 16, gpios)

gpio_clear: (UInt32, UInt32) -> () = \(gpio_port, gpios) => /do
  set_register (gpio_port + 20, gpios)

gpio_toggle: (UInt32, UInt32) -> () = \(gpio_port, gpios) => /do
  set_register (gpio_port + 24, gpios)

;; TODO
;; delay: UInt32 -> () = \dlyTicks => /do
;;   /let curTicks = get_register millis
;;   while((msTicks - curTicks) < dlyTicks)
;;
;; systick_handler: Bit -> () = \_ => /do
;;   set_register (millis, (get_register millis) + 1)

;; ┌─┐┌┐┌┌┬┐┬─┐┬ ┬
;; ├┤ │││ │ ├┬┘└┬┘
;; └─┘┘└┘ ┴ ┴└─ ┴

run: Bit -> () = \_ => /do

  ;; disable watchdog
  set_register (wdog_ctrl, 0)

  enable_gpio_clock 1

  ;; gpio_setup (led_red_port, gpio_mode_wired_and, led_red_pin)
  ;; gpio_setup (led_green_port, gpio_mode_wired_and, led_green_pin)

  gpio_set (led_red_port, led_red_pin)
  gpio_set (led_green_port, led_green_pin)

  ;; set systick clock source to stk_csr_clksource_ahb
  set_register (stk_csr, ((get_register stk_csr) & stk_csr_clksource_flipped) | (stk_csr_clksource_ahb & stk_csr_clksource))

  ;; set systick automatic reload value
  set_register (stk_rvr, 23999 & stk_rvr_reload)

  ;; enable systick counter
  set_register (stk_csr, (get_register stk_csr) |  stk_csr_enable)

  ;; enable systick interrupt
  set_register (stk_csr, (get_register stk_csr) | stk_csr_tickint)

  ;; TODO
  ;;while(1) {
  ;;  delay(1000);
  ;;  gpio_toggle(LED_RED_PORT, LED_RED_PIN);
  ;;  gpio_toggle(LED_GREEN_PORT, LED_GREEN_PIN);
  ;;}
