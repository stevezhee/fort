Int = /Unsigned 32
Bool = /Bool

Char = /Char
fputc: (Char, Handle) -> () = /extern "fputc"

Double = /Floating 64
h-put-f64: (Double, Handle) -> () = /extern "h_put_f64"

Handle = /Address (/Unsigned 64)
stdout: Handle = /extern "g_stdout"

output: a -> ()

;; Type = /Enum
;;   TyFloat: Int

;; typeof: a -> Type = /extern "typeof"

;; cast: a -> b

;; debug-h: (a, Handle) -> () = \(x, h) => /case typeof x /of
;;   TyFloat = \sz => /case sz /of
;;     64 = h-put-f64 (cast x, h)
;;     _ = fputs ("unknown float size", h)
;;   _ = fputs ("unknown type", h)

;;   ;; TyInt = \(_, _, ity) => /case ity /of
;;   ;;   TyChar

;; debug: a -> () = debug-h(, stdout)

;; debug: Double -> () = h-put-f64 (, stdout)

array-size: /Address (/Array sz a) -> Int

add: (a, a) -> a
+ = add
load: /Address a -> a
index: (/Address (/Array sz a), Int) -> /Address a
# = index
less-than: (a, a) -> Bool
< = less-than

debug: a -> ()

debug: Char -> () = fputc (, stdout)

debug: /Address (/Array sz a) -> () = \arr => /do
  output "{"
  go 0
  output "}"
  /where
    go: Int -> () = \i => /if
      i < array-size arr = /do
        /let c = load (arr # i)
        debug c
        go (i + 1)
      _ = ()

arrv = /array
  #"a"
  #"b"

alloca: () -> /Address a
store: (/Address a, a) -> ()
:= = store

main: () -> Int = \_ => /do
  ;; debug (1.3: Double)
  debug #"c"
  /let arr = alloca ()
  arr := arrv
  debug arr
;;   output ("hi there", #"c")
;;   output "\n"
  0