Int = /signed 32
Double = /floating 64
Bool = /bool
Handle = /address (/unsigned 64)

putc: (Int, Handle) -> () = /extern "putc"

stdout: Handle = /extern "g_stdout"

add: (a, a) -> a
+ = add

subtract: (a, a) -> a
- = subtract

multiply: (a, a) -> a
* = multiply

divide: (a, a) -> a
/ = divide

remainder: (a, a) -> a
% = remainder

equals: (a, a) -> Bool
== = equals

less-than: (a, a) -> Bool
< = less-than

less-than-or-equals: (a, a) -> Bool
<= = less-than-or-equals

shift-left: (a, a) -> a
<< = shift-left

bitwise-and: (a, a) -> a
& = bitwise-and

bitwise-or: (a, a) -> a
| = bitwise-or

cast: a -> b

write-pbm: Int -> () = \w => /do
  /let h = w
  /let limit2 = 4
  /let iter = 50
  goY(0)
    /where
      goY: Int -> () = \y => /if
        y < h = /do
          /let ci = ((2 * cast y) / cast h) - 1
          goX(0, 0, 0) ;; BAL: goX(0) somehow compiles??
            /where goX: (Int, Int, Int) -> () = \(x, byte-acc0, bit-num) => /if
              x < w = /do
                /let cr = ((2 * cast x) / cast w) - 1.5
                /let (tr, ti) = goI(0, 0, 0, 0, 0, ci, cr)
                /let byte-acc = (byte-acc0 << 1) | cast ((tr + ti) <= limit2)
                /if
                  bit-num == 7 = /do
                    putc(byte-acc, stdout)
                    goX(x + 1, 0, 0)
                  x == (w - 1) = /do
                    putc(byte-acc << (8 - (w % 8)), stdout)
                    goX(x + 1, 0, 0)
                  _ = goX(x + 1, byte-acc, bit-num + 1)
              _ = ()
          goY(y + 1)
        _ = ()
      goI: (Int, Double, Double, Double, Double, Double, Double) -> (Double, Double) = \(i, zi0, zr0, ti, tr, ci, cr) => /if
        (i < iter) & ((tr + ti) <= limit2) = /do
          /let zi = ((2 * zr0) * zi0) + ci
          /let zr = (tr - ti) + cr
          goI(i + 1, zi, zr, zi * zi, zr * zr, ci, cr)
        _ = (tr, ti)


                ;; /let (tr, ti) = goI(0, 0, 0, 0, 0)
                ;;   /where goI: (Int, Double, Double, Double, Double) -> (Double, Double) = \(i, zi, zr, tr, ti) => /if
                ;;     (i < iter) & ((tr + ti) <= limit2) =
                ;;       goI(i + 1, ((2 * zr) * zi) + ci, (tr - ti) + cr, zr * zr, zi * zi)
                ;;     _ = (tr, ti)
