Int = /Signed 32
UInt = /Unsigned 32
Double = /Floating 64
Bool = /Bool
Handle = /Address (/Unsigned 64)

Body = /Record
  x: Double
  y: Double
  z: Double
  vx: Double
  vy: Double
  vz: Double
  mass: Double

Bodies = /Address (/Array 5 Body)

pi: Double = 3.141592653589793
solar-mass: Double = (4 * pi) * pi
days-per-year: Double = 365.24

init-bodies = /array
  sun
  jupiter
  saturn
  uranus
  neptune

sun = /record
  x = 0
  y = 0
  z = 0
  vx = 0
  vy = 0
  vz = 0
  mass = solar-mass

jupiter = /record
  x = 4.84143144246472090e+00
  y = -1.16032004402742839e+00
  z = -1.03622044471123109e-01
  vx = 1.66007664274403694e-03 * days-per-year
  vy = 7.69901118419740425e-03 * days-per-year
  vz = -6.90460016972063023e-05 * days-per-year
  mass = 9.54791938424326609e-04 * solar-mass

saturn = /record
  x = 8.34336671824457987e+00
  y = 4.12479856412430479e+00
  z = -4.03523417114321381e-01
  vx = -2.76742510726862411e-03 * days-per-year
  vy = 4.99852801234917238e-03 * days-per-year
  vz = 2.30417297573763929e-05 * days-per-year
  mass = 2.85885980666130812e-04 * solar-mass

uranus = /record
  x = 1.28943695621391310e+01
  y = -1.51111514016986312e+01
  z = -2.23307578892655734e-01
  vx = 2.96460137564761618e-03 * days-per-year
  vy = 2.37847173959480950e-03 * days-per-year
  vz = -2.96589568540237556e-05 * days-per-year
  mass = 4.36624404335156298e-05 * solar-mass

neptune = /record
  x = 1.53796971148509165e+01
  y = -2.59193146099879641e+01
  z = 1.79258772950371181e-01
  vx = 2.68067772490389322e-03 * days-per-year
  vy = 1.62824170038242295e-03 * days-per-year
  vz = -9.51592254519715870e-05 * days-per-year
  mass = 5.15138902046611451e-05 * solar-mass

index: (/Address (/Array sz a), UInt) -> /Address a
# = index

;; array-size: /Address (/Array sz a) -> Int ;; BAL: should be array-count

advance-n: (Bodies, Double, Int) -> () = \(bodies, adv, n) =>
  ;; go(0)
  ()
;;   /where
;;     go: Int -> () = \i => /if
;;       i < n = /do
;;         advance(bodies, adv)
;;         go(i + 1)
;;       _ = ()

sqr: Double -> Double = \x => x * x

load : /Address a -> a

atoi: /String -> Int = /extern "atoi"
alloca: () -> /Address a
output: a -> ()

main: (Int, /Address (/Array 2 /String)) -> Int = \(argc, argv) => /do
  /let n = /if
    argc > 1 = atoi(load (argv # 1)) ;; BAL: should be error if no default on the if
    _ = 1000

  /let bodies = alloca ()
  bodies := init-bodies
  
  output (energy bodies)
  offset-momentum bodies
  output (energy bodies)
  advance-n (bodies, 0.01, n)
  output (energy bodies)

  0

sqrt: a -> a

energy: Bodies -> Double = \bodies => /do
  output "energy"
  goI (0, 0)
  /where
    goI: (UInt, Double) -> Double = \(i, e) => /if
      i < array-size bodies = /do
        output e
        /let body = bodies # i
        /let temp1 = 0.5 * (load (mass body))
        /let temp2 = (sqr (load (vx body)) + sqr (load (vy body))) + sqr (load (vz body))
        /let e' = goJ(i + 1, e + (temp1 * temp2), body)
        goI (i + 1, e')
        /where
          goJ: (UInt, Double, /Address Body) -> Double = \(j, e, body) => /if
            j < array-size bodies = /do
              /let body2 = bodies # j
              /let dx = load (x body) - load (x body2)
              /let dy = load (y body) - load (y body2)
              /let dz = load (z body) - load (z body2)
              /let distance = sqrt((sqr dx + sqr dy) + sqr dz)
              goJ(j + 1, e - ((load (mass body) * load (mass body2)) / distance), body)
            _ = e
      _ = e

;; advance: (Bodies, Double) -> () = \(bodies, dt) => /do
;;   goI(0)
;;   /where
;;     goI: Int -> () = \i => /if
;;       i < array-size bodies = /do
;;         /let body = bodies # i
;;         goJ(i + 1)
;;         goI(i + 1)
;;           /where
;;             goJ: Int -> () = \j => /if
;;               j < array-size bodies = /do
;;                 /let body2 = bodies # j
;;                 /let dx = x body - x body2
;;                 /let dy = y body - y body2
;;                 /let dz = z body - z body2
;;                 /let distanced = (sqr dx + sqr dy) + sqr dz
;;                 /let distance = sqrt(distanced)
;;                 /let mag = dt / (distanced * distance)
;;                 /set body
;;                   vx = vx body - ((dx * mass body2) * mag)
;;                   vy = vy body - ((dy * mass body2) * mag)
;;                   vz = vz body - ((dz * mass body2) * mag)
;;                 /set body2
;;                   vx = vx body2 + ((dx * mass body) * mag)
;;                   vy = vy body2 + ((dy * mass body) * mag)
;;                   vz = vz body2 + ((dz * mass body) * mag)
;;                 goJ(j + 1)
;;               _ = ()
;;       _ = ()

array-size: /Address (/Array sz a) -> UInt

negate: Double -> Double = \x => 0 - x ;; until the fneg instr is supported in llvm haskell

offset_momentum: Bodies -> () = \bodies => /do
  go(0, 0, 0, 0)
  /where
    go: (UInt, Double, Double, Double) -> () = \(i, px, py, pz) => /if
      i < array-size bodies = /do
        /let body = bodies # i
        /let m = load (mass body)
        go(i + 1, px + (load (vx body) * m), py + (load (vy body) * m), pz + (load (vz body) * m))
      _ = /do
        /let body0 = bodies # 0
        (vx body0) := (f px)
        (vy body0) := (f py)
        (vz body0) := (f pz)
    f: Double -> Double = \a => negate (a / solar-mass)
      
store: (/Address a, a) -> ()
:= = store

putc: (Int, Handle) -> () = /extern "putc"

stdout: Handle = /extern "g_stdout"

add: (a, a) -> a
+ = add

subtract: (a, a) -> a
- = subtract

multiply: (a, a) -> a
* = multiply

divide: (a, a) -> a
/ = divide

remainder: (a, a) -> a
% = remainder

equals: (a, a) -> Bool
== = equals

greater-than: (a, a) -> Bool
> = greater-than

less-than: (a, a) -> Bool
< = less-than

less-than-or-equals: (a, a) -> Bool
<= = less-than-or-equals

shift-left: (a, a) -> a
<< = shift-left

bitwise-and: (a, a) -> a
& = bitwise-and

bitwise-or: (a, a) -> a
| = bitwise-or

cast: a -> b
